/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "thrudoc.h"
#include "thrift_client.h"
#include <string.h>

gboolean thrift_thrudoc_get_buckets (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{
  if (!thrift_thrudoc_send_get_buckets (client, error))
    return 0;
  if (!thrift_thrudoc_recv_get_buckets (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_get_buckets (ThriftThrudocClient * client, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "getBuckets", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getBuckets_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_get_buckets (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "getBuckets", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size8;
              ThriftType _etype11;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype11, &_size8, error)) < 0)
                return 0;
              xfer += ret;
              *_return = g_ptr_array_new ();
              guint32 _i12;
              for (_i12 = 0; _i12 < _size8; ++_i12)
              {
                gchar * _elem13;
                if ((ret = thrift_protocol_read_string (protocol, &_elem13, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem13);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, const gchar * value, GError ** error)
{
  if (!thrift_thrudoc_send_put (client, bucket, key, value, error))
    return 0;
  thrift_thrudoc_recv_put (client, error);
  return 1;
}

gboolean thrift_thrudoc_send_put (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "put", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "put_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, key, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, value, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put (ThriftThrudocClient * client, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "put", 3) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_get (ThriftThrudocClient * client, gchar ** _return, const gchar * bucket, const gchar * key, GError ** error)
{
  if (!thrift_thrudoc_send_get (client, bucket, key, error))
    return 0;
  if (!thrift_thrudoc_recv_get (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_get (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "get", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "get_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, key, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_get (ThriftThrudocClient * client, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "get", 3) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRING) {
            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_remove (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, GError ** error)
{
  if (!thrift_thrudoc_send_remove (client, bucket, key, error))
    return 0;
  thrift_thrudoc_recv_remove (client, error);
  return 1;
}

gboolean thrift_thrudoc_send_remove (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "remove", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "remove_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, key, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_remove (ThriftThrudocClient * client, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "remove", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put_value (ThriftThrudocClient * client, gchar ** _return, const gchar * bucket, const gchar * value, GError ** error)
{
  if (!thrift_thrudoc_send_put_value (client, bucket, value, error))
    return 0;
  if (!thrift_thrudoc_recv_put_value (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_put_value (ThriftThrudocClient * client, const gchar * bucket, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "putValue", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "putValue_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, value, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put_value (ThriftThrudocClient * client, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "putValue", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRING) {
            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_scan (ThriftThrudocClient * client, ThriftThrudocScanResponse ** _return, const gchar * bucket, const gchar * seed, const gint32 count, GError ** error)
{
  if (!thrift_thrudoc_send_scan (client, bucket, seed, count, error))
    return 0;
  if (!thrift_thrudoc_recv_scan (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_scan (ThriftThrudocClient * client, const gchar * bucket, const gchar * seed, const gint32 count, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "scan", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "seed", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, seed, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32(protocol, count, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_scan (ThriftThrudocClient * client, ThriftThrudocScanResponse ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "scan", 4) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_put_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_put_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_put_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "putList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "putList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "putList", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size15;
              ThriftType _etype18;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype18, &_size15, error)) < 0)
                return 0;
              xfer += ret;
              *_return = g_ptr_array_new ();
              guint32 _i19;
              for (_i19 = 0; _i19 < _size15; ++_i19)
              {
                ThriftThrudocThrudocException * _elem20;
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem20), protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem20);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_get_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_get_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_get_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_get_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "getList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_get_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "getList", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size22;
              ThriftType _etype25;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype25, &_size22, error)) < 0)
                return 0;
              xfer += ret;
              *_return = g_ptr_array_new ();
              guint32 _i26;
              for (_i26 = 0; _i26 < _size22; ++_i26)
              {
                ThriftThrudocListResponse * _elem27;
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem27), protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem27);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_remove_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_remove_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_remove_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_remove_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "removeList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "removeList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_remove_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "removeList", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size29;
              ThriftType _etype32;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype32, &_size29, error)) < 0)
                return 0;
              xfer += ret;
              *_return = g_ptr_array_new ();
              guint32 _i33;
              for (_i33 = 0; _i33 < _size29; ++_i33)
              {
                ThriftThrudocThrudocException * _elem34;
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem34), protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem34);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put_value_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_put_value_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_put_value_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_put_value_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "putValueList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "putValueList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put_value_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "putValueList", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size36;
              ThriftType _etype39;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype39, &_size36, error)) < 0)
                return 0;
              xfer += ret;
              *_return = g_ptr_array_new ();
              guint32 _i40;
              for (_i40 = 0; _i40 < _size36; ++_i40)
              {
                ThriftThrudocListResponse * _elem41;
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem41), protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem41);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_admin (ThriftThrudocClient * client, gchar ** _return, const gchar * op, const gchar * data, GError ** error)
{
  if (!thrift_thrudoc_send_admin (client, op, data, error))
    return 0;
  if (!thrift_thrudoc_recv_admin (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_admin (ThriftThrudocClient * client, const gchar * op, const gchar * data, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "admin", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "admin_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, op, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, data, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_admin (ThriftThrudocClient * client, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error);

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "admin", 5) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  ThriftThrudocThrudocException * e;
  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRING) {
            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case -1:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (e), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

GType thrift_thrudoc_client_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocClientClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      NULL, /* class_init */
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocClient),
      0, /* n_preallocs */
      NULL, /* instance_init */
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_CLIENT, 
                                   "ThriftThrudocClientType",
                                   &type_info, 0);
  }

  return type;
}

