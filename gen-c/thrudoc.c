/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#include "thrudoc.h"
#include "thrift_client.h"
#include <string.h>

gboolean thrift_thrudoc_get_buckets (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{
  if (!thrift_thrudoc_send_get_buckets (client, error))
    return 0;
  if (!thrift_thrudoc_recv_get_buckets (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_get_buckets (ThriftThrudocClient * client, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "getBuckets", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getBuckets_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_get_buckets (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "getBuckets", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size7;
              ThriftType _etype10;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype10, &_size7, error)) < 0)
                return 0;
              xfer += ret;
              guint32 _i11;
              for (_i11 = 0; _i11 < _size7; ++_i11)
              {
                gchar * _elem12 = NULL;
                if ((ret = thrift_protocol_read_string (protocol, &_elem12, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem12);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, const gchar * value, GError ** error)
{
  if (!thrift_thrudoc_send_put (client, bucket, key, value, error))
    return 0;
  thrift_thrudoc_recv_put (client, error);
  return 1;
}

gboolean thrift_thrudoc_send_put (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "put", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "put_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, key, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, value, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put (ThriftThrudocClient * client, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "put", 3) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_get (ThriftThrudocClient * client, gchar ** _return, const gchar * bucket, const gchar * key, GError ** error)
{
  if (!thrift_thrudoc_send_get (client, bucket, key, error))
    return 0;
  if (!thrift_thrudoc_recv_get (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_get (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "get", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "get_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, key, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_get (ThriftThrudocClient * client, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "get", 3) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRING) {
            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_remove (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, GError ** error)
{
  if (!thrift_thrudoc_send_remove (client, bucket, key, error))
    return 0;
  thrift_thrudoc_recv_remove (client, error);
  return 1;
}

gboolean thrift_thrudoc_send_remove (ThriftThrudocClient * client, const gchar * bucket, const gchar * key, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "remove", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "remove_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, key, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_remove (ThriftThrudocClient * client, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "remove", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put_value (ThriftThrudocClient * client, gchar ** _return, const gchar * bucket, const gchar * value, GError ** error)
{
  if (!thrift_thrudoc_send_put_value (client, bucket, value, error))
    return 0;
  if (!thrift_thrudoc_recv_put_value (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_put_value (ThriftThrudocClient * client, const gchar * bucket, const gchar * value, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "putValue", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "putValue_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, value, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put_value (ThriftThrudocClient * client, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "putValue", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRING) {
            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_scan (ThriftThrudocClient * client, ThriftThrudocScanResponse ** _return, const gchar * bucket, const gchar * seed, const gint32 count, GError ** error)
{
  if (!thrift_thrudoc_send_scan (client, bucket, seed, count, error))
    return 0;
  if (!thrift_thrudoc_recv_scan (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_scan (ThriftThrudocClient * client, const gchar * bucket, const gchar * seed, const gint32 count, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "scan", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "scan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, bucket, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "seed", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, seed, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32(protocol, count, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_scan (ThriftThrudocClient * client, ThriftThrudocScanResponse ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "scan", 4) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT) {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_put_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_put_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_put_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "putList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "putList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "putList", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size14;
              ThriftType _etype17;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype17, &_size14, error)) < 0)
                return 0;
              xfer += ret;
              guint32 _i18;
              for (_i18 = 0; _i18 < _size14; ++_i18)
              {
                GError * _elem19 = NULL;;
                if ((ret = thrift_thrudoc_thrudoc_exception_read (&_elem19, protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem19);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_get_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_get_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_get_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_get_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "getList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_get_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "getList", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size21;
              ThriftType _etype24;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype24, &_size21, error)) < 0)
                return 0;
              xfer += ret;
              guint32 _i25;
              for (_i25 = 0; _i25 < _size21; ++_i25)
              {
                ThriftThrudocListResponse * _elem26 = g_object_new (THRIFT_THRUDOC_TYPE_LIST_RESPONSE, NULL);;
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem26), protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem26);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_remove_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_remove_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_remove_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_remove_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "removeList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "removeList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_remove_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "removeList", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size28;
              ThriftType _etype31;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype31, &_size28, error)) < 0)
                return 0;
              xfer += ret;
              guint32 _i32;
              for (_i32 = 0; _i32 < _size28; ++_i32)
              {
                GError * _elem33 = NULL;;
                if ((ret = thrift_thrudoc_thrudoc_exception_read (&_elem33, protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem33);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_put_value_list (ThriftThrudocClient * client, GPtrArray ** _return, const GPtrArray * elements, GError ** error)
{
  if (!thrift_thrudoc_send_put_value_list (client, elements, error))
    return 0;
  if (!thrift_thrudoc_recv_put_value_list (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_put_value_list (ThriftThrudocClient * client, const GPtrArray * elements, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "putValueList", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "putValueList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)elements->len, error)) < 0)
        return 0;
      xfer += ret;
      int i;
      for (i = 0; i < (gint32)elements->len; i++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(elements, i)), protocol, error)) < 0)
          return 0;
        xfer += ret;
      }
      if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_put_value_list (ThriftThrudocClient * client, GPtrArray ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "putValueList", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_LIST) {
            {
              guint32 _size35;
              ThriftType _etype38;
              if ((ret = thrift_protocol_read_list_begin (protocol, &_etype38, &_size35, error)) < 0)
                return 0;
              xfer += ret;
              guint32 _i39;
              for (_i39 = 0; _i39 < _size35; ++_i39)
              {
                ThriftThrudocListResponse * _elem40 = g_object_new (THRIFT_THRUDOC_TYPE_LIST_RESPONSE, NULL);;
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem40), protocol, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem40);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_admin (ThriftThrudocClient * client, gchar ** _return, const gchar * op, const gchar * data, GError ** error)
{
  if (!thrift_thrudoc_send_admin (client, op, data, error))
    return 0;
  if (!thrift_thrudoc_recv_admin (client, _return, error))
    return 0;
  return 1;
}

gboolean thrift_thrudoc_send_admin (ThriftThrudocClient * client, const gchar * op, const gchar * data, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_write_message_begin (protocol, "admin", T_CALL, cseqid, error) < 0)
    return 0;

  {
    gint32 ret;
    gint32 xfer = 0;
    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "admin_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, op, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string(protocol, data, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
      return 0;
    xfer += ret;
  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_flush (protocol->transport, error))
    return 0;
  if (!thrift_transport_write_end (protocol->transport, error))
    return 0;

  return 1;
}

gboolean thrift_thrudoc_recv_admin (ThriftThrudocClient * client, gchar ** _return, GError ** error)
{

  gint32 rseqid;
  gchar * fname;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = THRIFT_CLIENT (client)->protocol;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0)
    return 0;

  if (mtype == T_EXCEPTION) {
    /* TODO: ThriftApplicationException x;
    x.read(iprot_); */
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw x; */
    return 0;
  } else if (mtype != T_REPLY) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::INVALID_MESSAGE_TYPE); */
    return 0;
  } else if (strncmp (fname, "admin", 5) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, error);
    thrift_protocol_read_message_end (protocol, error);
    thrift_transport_read_end (protocol->transport, error);
    /* TODO: error handling throw facebook::thrift::TApplicationException(facebook::thrift::TApplicationException::WRONG_METHOD_NAME); */
    return 0;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
      return 0;
    xfer += ret;
    if (name) g_free (name);
    

    while (1)
    {
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
        return 0;
      xfer += ret;
      if (name) g_free (name);
      if (ftype == T_STOP) {
        break;
      }
      switch (fid)
      {
        case 0:
          if (ftype == T_STRING) {
            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return 0;

  if (!thrift_transport_read_end (protocol->transport, error))
    return 0;

  return 1;
}

GType thrift_thrudoc_client_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocClientClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      NULL, /* class_init */
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocClient),
      0, /* n_preallocs */
      NULL, /* instance_init */
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_CLIENT, 
                                   "ThriftThrudocClientType",
                                   &type_info, 0);
  }

  return type;
}

