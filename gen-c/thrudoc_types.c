/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

#include "thrudoc_types.h"

gint32 thrift_thrudoc_thrudoc_exception_write (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  ThriftThrudocThrudocException * this_object = THRIFT_THRUDOC_THRUDOC_EXCEPTION(object);
  xfer += thrift_protocol_write_struct_begin (thrift_protocol, "ThrudocException");
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "what", T_STRING, 1);
  xfer += thrift_protocol_write_string(thrift_protocol, this_object->what);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "type", T_I32, 2);
  xfer += thrift_protocol_write_i32(thrift_protocol, (gint32)this_object->type);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_stop(thrift_protocol);
  xfer += thrift_protocol_write_struct_end(thrift_protocol);
  return xfer;
}

gint32 thrift_thrudoc_thrudoc_exception_read (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  gchar * fname;
  ThriftType ftype;
  gint16 fid;

  xfer += thrift_protocol_read_struct_begin (thrift_protocol, &fname);
  ThriftThrudocThrudocException * this_object = THRIFT_THRUDOC_THRUDOC_EXCEPTION(object);

  while (1)
  {
    xfer += thrift_protocol_read_field_begin (thrift_protocol, &fname, &ftype, &fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRING) {
          xfer += thrift_protocol_read_string (thrift_protocol, &this_object->what);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      case 2:
        if (ftype == T_I32) {
          gint32 ecast0;
          xfer += thrift_protocol_read_i32 (thrift_protocol, &ecast0);
          this_object->type = (ThriftThrudocExceptionType)ecast0;
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      default:
        xfer += thrift_protocol_skip (thrift_protocol, ftype);
        break;
    }
    xfer += thrift_protocol_read_field_end (thrift_protocol);
  }

  xfer += thrift_protocol_read_struct_end (thrift_protocol);

  return xfer;
}

void thrift_thrudoc_thrudoc_exception_instance_init (ThriftThrudocThrudocException * object)
{
  object->what = "";
}

void thrift_thrudoc_thrudoc_exception_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->write = thrift_thrudoc_thrudoc_exception_write;
}

GType thrift_thrudoc_thrudoc_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocThrudocExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_thrudoc_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocThrudocException),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_thrudoc_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocThrudocExceptionType",
                                   &type_info, 0);
  }

  return type;
}

gint32 thrift_thrudoc_element_write (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  ThriftThrudocElement * this_object = THRIFT_THRUDOC_ELEMENT(object);
  xfer += thrift_protocol_write_struct_begin (thrift_protocol, "Element");
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "bucket", T_STRING, 1);
  xfer += thrift_protocol_write_string(thrift_protocol, this_object->bucket);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "key", T_STRING, 2);
  xfer += thrift_protocol_write_string(thrift_protocol, this_object->key);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "value", T_STRING, 3);
  xfer += thrift_protocol_write_string(thrift_protocol, this_object->value);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_stop(thrift_protocol);
  xfer += thrift_protocol_write_struct_end(thrift_protocol);
  return xfer;
}

gint32 thrift_thrudoc_element_read (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  gchar * fname;
  ThriftType ftype;
  gint16 fid;

  xfer += thrift_protocol_read_struct_begin (thrift_protocol, &fname);
  ThriftThrudocElement * this_object = THRIFT_THRUDOC_ELEMENT(object);

  while (1)
  {
    xfer += thrift_protocol_read_field_begin (thrift_protocol, &fname, &ftype, &fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRING) {
          xfer += thrift_protocol_read_string (thrift_protocol, &this_object->bucket);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      case 2:
        if (ftype == T_STRING) {
          xfer += thrift_protocol_read_string (thrift_protocol, &this_object->key);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      case 3:
        if (ftype == T_STRING) {
          xfer += thrift_protocol_read_string (thrift_protocol, &this_object->value);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      default:
        xfer += thrift_protocol_skip (thrift_protocol, ftype);
        break;
    }
    xfer += thrift_protocol_read_field_end (thrift_protocol);
  }

  xfer += thrift_protocol_read_struct_end (thrift_protocol);

  return xfer;
}

void thrift_thrudoc_element_instance_init (ThriftThrudocElement * object)
{
  object->bucket = "";
  object->key = "";
  object->value = "";
}

void thrift_thrudoc_element_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->write = thrift_thrudoc_element_write;
}

GType thrift_thrudoc_element_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocElementClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_element_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocElement),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_element_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocElementType",
                                   &type_info, 0);
  }

  return type;
}

gint32 thrift_thrudoc_scan_response_write (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  ThriftThrudocScanResponse * this_object = THRIFT_THRUDOC_SCAN_RESPONSE(object);
  xfer += thrift_protocol_write_struct_begin (thrift_protocol, "ScanResponse");
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "elements", T_LIST, 1);
  {
    xfer += thrift_protocol_write_list_begin(thrift_protocol, T_STRUCT, this_object->elements->len);
    int i;
    for (i = 0; i < this_object->elements->len; i++)
    {
      xfer += thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(this_object->elements, i)), thrift_protocol);
    }
    xfer += thrift_protocol_write_list_end(thrift_protocol);
  }
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "seed", T_STRING, 2);
  xfer += thrift_protocol_write_string(thrift_protocol, this_object->seed);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_stop(thrift_protocol);
  xfer += thrift_protocol_write_struct_end(thrift_protocol);
  return xfer;
}

gint32 thrift_thrudoc_scan_response_read (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  gchar * fname;
  ThriftType ftype;
  gint16 fid;

  xfer += thrift_protocol_read_struct_begin (thrift_protocol, &fname);
  ThriftThrudocScanResponse * this_object = THRIFT_THRUDOC_SCAN_RESPONSE(object);

  while (1)
  {
    xfer += thrift_protocol_read_field_begin (thrift_protocol, &fname, &ftype, &fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_LIST) {
          {
            guint32 _size2;
            ThriftType _etype5;
            thrift_protocol_read_list_begin (thrift_protocol, &_etype5, &_size2);
            this_object->elements = g_ptr_array_new ();
            guint32 _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              ThriftThrudocElement * _elem7;
              xfer += thrift_struct_read (THRIFT_STRUCT (_elem7), thrift_protocol);
              g_ptr_array_add (this_object->elements, _elem7);
            }
            thrift_protocol_read_list_end (thrift_protocol);
          }
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      case 2:
        if (ftype == T_STRING) {
          xfer += thrift_protocol_read_string (thrift_protocol, &this_object->seed);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      default:
        xfer += thrift_protocol_skip (thrift_protocol, ftype);
        break;
    }
    xfer += thrift_protocol_read_field_end (thrift_protocol);
  }

  xfer += thrift_protocol_read_struct_end (thrift_protocol);

  return xfer;
}

void thrift_thrudoc_scan_response_instance_init (ThriftThrudocScanResponse * object)
{
  object->seed = "";
}

void thrift_thrudoc_scan_response_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->write = thrift_thrudoc_scan_response_write;
}

GType thrift_thrudoc_scan_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocScanResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_scan_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocScanResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_scan_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocScanResponseType",
                                   &type_info, 0);
  }

  return type;
}

gint32 thrift_thrudoc_list_response_write (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  ThriftThrudocListResponse * this_object = THRIFT_THRUDOC_LIST_RESPONSE(object);
  xfer += thrift_protocol_write_struct_begin (thrift_protocol, "ListResponse");
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "element", T_STRUCT, 1);
  xfer += thrift_struct_write (THRIFT_STRUCT (this_object->element), thrift_protocol);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_begin (thrift_protocol, "ex", T_STRUCT, 2);
  xfer += thrift_struct_write (THRIFT_STRUCT (this_object->ex), thrift_protocol);
  xfer += thrift_protocol_write_field_end (thrift_protocol);
  xfer += thrift_protocol_write_field_stop(thrift_protocol);
  xfer += thrift_protocol_write_struct_end(thrift_protocol);
  return xfer;
}

gint32 thrift_thrudoc_list_response_read (ThriftStruct * object, ThriftProtocol * thrift_protocol)
{
  gint32 xfer = 0;
  gchar * fname;
  ThriftType ftype;
  gint16 fid;

  xfer += thrift_protocol_read_struct_begin (thrift_protocol, &fname);
  ThriftThrudocListResponse * this_object = THRIFT_THRUDOC_LIST_RESPONSE(object);

  while (1)
  {
    xfer += thrift_protocol_read_field_begin (thrift_protocol, &fname, &ftype, &fid);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT) {
          xfer += thrift_struct_read (THRIFT_STRUCT (this_object->element), thrift_protocol);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      case 2:
        if (ftype == T_STRUCT) {
          xfer += thrift_struct_read (THRIFT_STRUCT (this_object->ex), thrift_protocol);
        } else {
          xfer += thrift_protocol_skip (thrift_protocol, ftype);
        }
        break;
      default:
        xfer += thrift_protocol_skip (thrift_protocol, ftype);
        break;
    }
    xfer += thrift_protocol_read_field_end (thrift_protocol);
  }

  xfer += thrift_protocol_read_struct_end (thrift_protocol);

  return xfer;
}

void thrift_thrudoc_list_response_instance_init (ThriftThrudocListResponse * object)
{
}

void thrift_thrudoc_list_response_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->write = thrift_thrudoc_list_response_write;
}

GType thrift_thrudoc_list_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocListResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_list_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocListResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_list_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocListResponseType",
                                   &type_info, 0);
  }

  return type;
}

