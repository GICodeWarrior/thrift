/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

#include "thrudoc_types.h"
#include "thrift.h"

gint32 thrift_thrudoc_thrudoc_exception_read (GError ** ex, ThriftProtocol * protocol, GError ** error)
{
    gint32 ret;
    gint32 xfer = 0;
    gchar * name;
    ThriftType ftype;
    gint16 fid;

    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
        return -1;
    xfer += ret;
    if (name) g_free (name);

    while (1)
    {
        if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
            return -1;
        xfer += ret;
        if (name) g_free (name);
        if (ftype == T_STOP) {
            break;
        }
        switch (fid)
        {
            case 1:
                if (ftype == T_STRING) {
                    gchar * what;
                    if ((ret = thrift_protocol_read_string (protocol, &what, error)) < 0)
                        return -1;
                    xfer += ret;
                    g_set_error (ex, 0, 0, "%s", what);
                    if (what) g_free (what);
                } else {
                    if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
                        return -1;
                    xfer += ret;
                }
                break;
            default:
                if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
                    return -1;
                xfer += ret;
                break;
        }
        if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
            return -1;
        xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
        return -1;
    xfer += ret;

    return xfer;
}

gint32 thrift_thrudoc_element_write (ThriftStruct * object, ThriftProtocol * protocol, GError ** error)
{
  gint32 ret;
  gint32 xfer = 0;
  ThriftThrudocElement * this_object = THRIFT_THRUDOC_ELEMENT(object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Element", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bucket", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->bucket, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->value, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  return xfer;
}

gint32 thrift_thrudoc_element_read (ThriftStruct * object, ThriftProtocol * protocol, GError ** error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar * name;
  ThriftType ftype;
  gint16 fid;

  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    return -1;
  xfer += ret;
  if (name) g_free (name);
  ThriftThrudocElement * this_object = THRIFT_THRUDOC_ELEMENT(object);

  while (1)
  {
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      return -1;
    xfer += ret;
    if (name) g_free (name);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRING) {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->bucket, error)) < 0)
            return -1;
          xfer += ret;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING) {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING) {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void thrift_thrudoc_element_instance_init (ThriftThrudocElement * object)
{
  THRIFT_UNUSED_VAR (object);
  object->bucket = NULL;
  object->key = NULL;
  object->value = NULL;
}

void thrift_thrudoc_element_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->read = thrift_thrudoc_element_read;
  thrift_struct_class->write = thrift_thrudoc_element_write;
}

GType thrift_thrudoc_element_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocElementClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_element_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocElement),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_element_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocElementType",
                                   &type_info, 0);
  }

  return type;
}

gint32 thrift_thrudoc_scan_response_write (ThriftStruct * object, ThriftProtocol * protocol, GError ** error)
{
  gint32 ret;
  gint32 xfer = 0;
  ThriftThrudocScanResponse * this_object = THRIFT_THRUDOC_SCAN_RESPONSE(object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ScanResponse", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "elements", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    if ((ret = thrift_protocol_write_list_begin(protocol, T_STRUCT, (gint32)this_object->elements->len, error)) < 0)
      return -1;
    xfer += ret;
    int i;
    for (i = 0; i < (gint32)this_object->elements->len; i++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT (g_ptr_array_index(this_object->elements, i)), protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_list_end(protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "seed", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string(protocol, this_object->seed, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  return xfer;
}

gint32 thrift_thrudoc_scan_response_read (ThriftStruct * object, ThriftProtocol * protocol, GError ** error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar * name;
  ThriftType ftype;
  gint16 fid;

  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    return -1;
  xfer += ret;
  if (name) g_free (name);
  ThriftThrudocScanResponse * this_object = THRIFT_THRUDOC_SCAN_RESPONSE(object);

  while (1)
  {
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      return -1;
    xfer += ret;
    if (name) g_free (name);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_LIST) {
          {
            guint32 _size1;
            ThriftType _etype4;
            if ((ret = thrift_protocol_read_list_begin (protocol, &_etype4, &_size1, error)) < 0)
              return -1;
            xfer += ret;
            guint32 _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              ThriftThrudocElement * _elem6 = g_object_new (THRIFT_THRUDOC_TYPE_ELEMENT, NULL);;
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->elements, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING) {
          if ((ret = thrift_protocol_read_string (protocol, &this_object->seed, error)) < 0)
            return -1;
          xfer += ret;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void thrift_thrudoc_scan_response_instance_init (ThriftThrudocScanResponse * object)
{
  THRIFT_UNUSED_VAR (object);
  /* object->elements = not-implemented; */
  object->seed = NULL;
}

void thrift_thrudoc_scan_response_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->read = thrift_thrudoc_scan_response_read;
  thrift_struct_class->write = thrift_thrudoc_scan_response_write;
}

GType thrift_thrudoc_scan_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocScanResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_scan_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocScanResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_scan_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocScanResponseType",
                                   &type_info, 0);
  }

  return type;
}

gint32 thrift_thrudoc_list_response_write (ThriftStruct * object, ThriftProtocol * protocol, GError ** error)
{
  gint32 ret;
  gint32 xfer = 0;
  ThriftThrudocListResponse * this_object = THRIFT_THRUDOC_LIST_RESPONSE(object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListResponse", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "element", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->element), protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ex", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex), protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop(protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end(protocol, error)) < 0)
    return -1;
  xfer += ret;
  return xfer;
}

gint32 thrift_thrudoc_list_response_read (ThriftStruct * object, ThriftProtocol * protocol, GError ** error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar * name;
  ThriftType ftype;
  gint16 fid;

  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    return -1;
  xfer += ret;
  if (name) g_free (name);
  ThriftThrudocListResponse * this_object = THRIFT_THRUDOC_LIST_RESPONSE(object);

  while (1)
  {
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      return -1;
    xfer += ret;
    if (name) g_free (name);
    if (ftype == T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT) {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->element), protocol, error)) < 0)
            return -1;
          xfer += ret;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT) {
          if ((ret = thrift_thrudoc_thrudoc_exception_read (&this_object->ex, protocol, error)) < 0)
            return -1;
          xfer += ret;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

void thrift_thrudoc_list_response_instance_init (ThriftThrudocListResponse * object)
{
  THRIFT_UNUSED_VAR (object);
  object->element = g_object_new (THRIFT_THRUDOC_TYPE_ELEMENT, NULL);
  object->ex = NULL;
}

void thrift_thrudoc_list_response_class_init (ThriftStructClass * thrift_struct_class)
{
  thrift_struct_class->read = thrift_thrudoc_list_response_read;
  thrift_struct_class->write = thrift_thrudoc_list_response_write;
}

GType thrift_thrudoc_list_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftThrudocListResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc)thrift_thrudoc_list_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftThrudocListResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc)thrift_thrudoc_list_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftThrudocListResponseType",
                                   &type_info, 0);
  }

  return type;
}

